<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>FMV-KB611のページ -- もしかしたら開発室</title>
<style>
<!--
	/* 全体的な */
	* {
		margin:0;
		padding:0;
	}
	body {
		font-family:monospace;
		font-size:16px;
		color:#FFFFFF;
		background-color:#000000;
		margin-left:8px; margin-right:8px;
		line-height: 1.4;
	}
	h1 {font-size:28px; margin-top:16px; margin-bottom:16px; padding:8px; text-align: center; color:#000000; background:#C0C0C0;}
	h2 {font-size:24px; margin-top:3ex; padding:8px; border-top:1px solid #C0C0C0; border-bottom:1px solid #C0C0C0; width:100%;}
	h3 {font-size:20px; margin-top:1ex; padding:8px; border-bottom:1px solid #404040; width:100%;}
	h4 {font-size:16px;}
	
	p {margin-top:0.5ex; margin-bottom:1ex; text-indent: 1em;}
	
	table {font-size:14px; margin-left:10%; margin-right:10%; margin-top:3ex; margin-bottom:3ex; border-collapse:collapse; border:1px solid #C0C0C0;}
	th {padding:2px; border:1px solid #C0C0C0; background:#404040;}
	td {padding:2px; border:1px solid #C0C0C0;}

	/* 特定用途用 */
	.body {margin-right:5%;}
	.block {margin-top:1ex; margin-bottom:3ex; margin-left:1em;}
	.list {margin-top:0.5ex; margin-bottom:1ex; margin-left:3em;}
	
	.memo {display:table; border:1px solid #808080; margin-left:10%; margin-right:10%; margin-top:2ex; margin-bottom:2ex;}
	.memo_blk1 {display: table-cell; padding:8px; white-space:nowrap; font-weight:bold;}
	.memo_blk2 {display: table-cell; padding:8px; font-size:14px; margin-right:10%; color:#E0E0E0;}

	.header {text-align:right; font-size:12px;}
	.footer {margin-top:2ex; padding:8px; border-top:1px solid #C0C0C0;}

	/* リンクスタイル */
	a:link {color:#8080FF;}
	a:visited {color:#FFC080;}
	a:active {color:#FF8080;}
-->
</style>
</head>

<body>
<div class="header">
	<div>2006/07/12 新設</div><div>2009/07/18 全面書換</div><div>2015/01 リニューアル、一部記述の変更</div>
</div>

<h1>FMV-KB611のページ</h1>

<div style="text-align: center">
	<IMG src=./image/fmv-kb611.jpg>
</div>

<div class="body">
<h2>はじめに</h2>
<div class="block">
	<p>親指シフトキーボードFMV-KB611の情報を扱うページです。親指シフトや、FMV-KB611のキーボードとしての出来などは、既に良くまとめられたサイトが存在するのでここでは扱いません。ここでは、内部の制御系に関する事をまとめました。</p>
	<p>親指シフターの世界では、FMV-KB611について「専用のキーボードドライバをインストールすることで親指シフト入力に対応するキーボード」と認識されているのではないかと思います。実際そのための機能も持っているのですが、FMV-KB211等のように、キーボードドライバを入れずに親指シフト入力を行うこともできてしまいます。さらに、これらの動作は専用のコマンドバイト列をキーボードに送ることで制御可能です。このページでは、この辺りについて掘り下げて説明してみたいと思います。</p>
	<p>元々は、自作のPC用OSでFMV-KB611での親指シフト入力に対応させたかったがために解析してみたのですが(通信データの観察と、そこからの総当たり作戦の成果物です)、例えば、Windows以外のOS用にドライバを書く場合や、USB接続・Bluetooth接続などの変換アダプタを作ったりするのに参考になるのではないかと思います(USBの方は<a href="./dev_hw.htm">必要に迫られて変換アダプタを作ってしまいましたが</a>)。</p>
	<p>なお、現在では後継機種として、FMV-KB613が登場しています。こちらも「KB611と同一仕様」とのことなので、以下KB611をKB613と読み替えても差し支えないと思います。また、前身のキーボードとして、OASYS/V用のキーボード(OAKB-193)とFMV-TOWNS用のキーボード(FMVTW-KBS)が存在します。初期のものは、LEDが多い(かな/英数入力、ローマ字入力モードの表示が存在した)、Windowsキー等が無い、「@/`」キーの色がグレー等の違いがあるようですが、こちらも制御的には同一と考えられますので、読み替えて構わないと思います。</p>
</div>

<h2>動作ブロック</h2>
<div class="block">
	
	<p>便宜的に、普通のキーボードと異なる動作をする部分を2つのブロックに分けて考えます。一つはFMV-KB211由来のブロック(以下互換ブロック)で、もう一つはKB611以降で追加されたと思われるブロック(以下611ブロック)です。</p>

	<h3>互換ブロック</h2>
	<div class="block">
		<p>キーボード側で親指シフト動作を行うブロックです。この親指シフト動作というのは、ホストから普通の106キーボードの入力として見えるように、親指シフトの入力を「106キーボードの対応するJISかな刻印を入力する操作」に変換する動作です。

		<div class="memo">
			<div class="memo_blk1">例</div>
			<div class="memo_blk2">「親指左」＋「W / え / か」 → 「5 / %（JIS配列で『え / ぇ』)」を通知</div>
		</div>

		<p>つまり、JISかな入力に対応した環境であれば、このキーボードを接続するだけですぐに親指シフトが使えるように作られています(!!)。</p>
		
		<p>このとき出力されるキーコードは完全に106キーボードの範囲内です。例えば、親指キーを単独打鍵しても、「親指キー」を示すコードは出てきませんし、英字や取消などについても、意味合いの近いキーのコードが出力されます。</p>
		
		<p>しかしながらこの機能が動いていると、かな入力のときは良いですが、英字入力では目茶苦茶なことになってしまうのが容易に想像できます。そこで、このキーボードでは、「CapsLock」や「カタカナひらがな」の打鍵など、「ユーザが入力モードを遷移させた」と思われるようなキー操作が行われた場合、その遷移先モードに合わせて、自動的に親指処理を有効/無効にするようになっています。</p>

		<p>「なんだ便利じゃん。ドライバ作んのやめて、もうこれ使ってれば良くね?」と思いたいところですが、実は厄介な問題が待っています。キーボード側に組み込まれている入力モードの遷移操作は<b>OAK/Vの操作</b>が基準になっていて、MS-IME等で一般的な操作では内部のモードを連動させることができません。しかも、Windowsアプリでは<b>お節介で</b>入力モードを切り換えることもできます(そうしている奴らも多い)ので、このままだとキーボードが理解している入力モードと食い違って、所謂「モードずれ」が発生する可能性があります。</p>
		<p>こんなトラブルを見越してなのか、KB211ではこの内部で保持しているモードを計算機側から変更することができるような機能が用意されており、これを利用して常時意図したモードにすることができます。実際、Windows標準のFMV-KB211用ドライバでも、この制御が行われています。ただ、この制御が少々厄介でして、何も考えないで組むとM$の実装のように、かな入力時の英数字入力でバグを抱え込むことになります。</p>

		<p>このようなこともあってか、キーボード側で親指シフト動作を行う路線は、KB611以降だと一般的ではなくなりました。よって、KB611以降では、これらの親指シフト動作を完全に無効化することが可能です。無効に設定した場合、キー操作によるモード遷移は起きなくなり、親指キー等も専用のコードを返すようになります。</p>

		<p>また、親指シフトの同時打鍵判定自体はするものの、106配列に変換して出力するのではなく、「同時打鍵マーカー方式(<a href="http://nicola.sunicom.co.jp/spec/kikaku.htm">NICOLA規格書</a>の実装例を参照)」と似た形で行うモードもあります。この設定にした時も、各キー固有のコードを返し、キー操作でモード遷移しないようになります。</p>
	</div>
	
	<h3>611ブロック</h2>
	<div class="block">
		<p>先程の互換ブロックの動作に変化を加えたり、出力するキーコードの設定など、拡張部分に関して設定を行います。OASYS用に拡張されたキーのコード出力を行うかどうかといった設定はもちろんのこと、互換ブロックの親指シフト動作について、使い勝手を向上させるような設定なども存在します。基本的に、「一回設定してしまえばおしまい」なコマンドしか無さそうですので、理解するのは容易かと思います。</p>
	</div>
</div>

<h2>キーボードへのデータの送り方</h2>
<div class="block">
<p>FMV-KB611で拡張された機能を制御する為には、PS/2のプロトコルにしたがって、以下の3バイトをキーボードへ送ります。</p>

	<div class="memo">
		<div class="memo_blk1">0xF0 0x8C (コマンド)</div>
	</div>

	<p>0xF0は本来「スキャンコード変更コマンド」で、次に送る1バイトの引数によって、キーボードが送信するキーコードの形式を変更するものです。FMV-KB611では、このコマンドを拡張する形で制御コマンドを実装してあります。「スキャンコード変更コマンド」の引数は0～3(0は現在値を通知)の範囲なので、この形式のコマンドを普通のキーボードへ送ろうとすると、0x8C送信直後に再送要求(ようはエラー)が来てしまい、受け付けてもらえないはずです。</p>

	<p>つまり、上記コマンドを受け取るかどうかで、FMV-KB611か、それ以外のキーボードかが判別できることになります。</p>
	<p>しかし、近頃の粗悪なキーボードの中には、変なデータを送りつけてもACKを返すひどいキーボードもあるようです。このような場合は、上記の方法で判別が効かないので注意する必要があります。</p>
	<div class="memo">
		<div class="memo_blk1">再送要求の扱い方</div>
		<div class="memo_blk2"><p>PS/2キーボードのプロトコルによれば、もしホストがコマンド送信中にキーボードからエラー応答が来た場合、<b>キーボード側は自動的に最初のバイトを待つフェーズに戻ります</b>。つまり、データ化けが起きてリトライしたりする場合は、コマンドを最初のバイトから送り直さなければいけません。エラーになったバイトから…ではないので注意が必要です。</p></div>
	</div>
</pre>

	<div class="memo">
		<div class="memo_blk1">PC上での扱い方</div>
		<div class="memo_blk2">
			<p>実際にPC上から送ってみようとする場合に必要な情報をメモしておきます。以下の手順を参考にして下さい。</p>
			<ol class="list">
			  <li>I/Oポート0x64のビット1が0になるまで監視</li>
			  <li>I/Oポート0x60に、送信したいデータを1バイト書き込む</li>
			  <li>I/Oポート0x64のビット0が1になるまで待つか、キーボード割り込みが来るまで待つ。</li>
			  <li>I/Oポート0x60を読んで、0xFA(ACK)が読めれば送信成功。0xFE(RESEND)が読めたら失敗なので、1に戻る。</li>
			</ol>
			<p>複数バイト送りたければ、これを送りたいバイト数分繰りかえせばOKです。</p>
			<p>さらに深く知りたい方は、以下のサイトを参考にされると良いかもしれません。</p>
			<ul class="list">
				<li><a href = "http://community.osdev.info/index.php?%28AT%29keyboard">OS Wiki内の(AT)keyboard</a></li>
				<li><a href = "http://www.asahi-net.or.jp/~WR7S-NKMR/MiddleWare/keyboard/">B級なi8042の研究(ミドルウェア編)</a></li>
			</ul>
		</div>
	</div>

</div>

<h2>コマンド一覧</h2>
<div class="block">
	<h3>互換ブロック</h3>
	<div class="block">
		<p>まず始めに、互換ブロックの制御コマンドから説明します(つまり、ここの記述はFMV-KB211等とも互換があります)。コマンド0x00を除いて、全て内部モードの遷移を行うコマンドです。コマンド表の見方は以下です。</p>

		<table>
			<tr><th>コマンド</th>	<td>キーボードへ送る上記コマンド列の3バイト目の値。</td></tr>
			<tr><th>モード</th>		<td>当該コマンド実行後、コマンド0x00を送ったときに返却される内部モードの値を、<br>スキャンコード2のキーコードと見なしてスキャンコード1へ変換したもの<br>(PC上から普通に扱うと、読み取れる値はこちらになる)<br>ハイフンはモード遷移が発生しないことを示す。</td></tr>
			<tr><th>意味</th>		<td>モード遷移が発生するコマンドでは、遷移先モードの説明。<br>遷移が発生しないコマンドでは、コマンドの説明。</td></tr>
		</table>

		<p>コマンド表は以下です。</p>
		<table>
			<tr><th>コマンド</th><th>モード</th><th>意味</th></tr>
			<tr><td>0x00</td><td>--</td><td>内部モード参照コマンド。<br>3バイト目のACKの後に、内部モードの値を返す(1バイト)。<br>スキャンコード変換しない場合、内部モードの値は対応するコマンド番号と同じ。</td></tr>
			<tr><td>0x01</td><td>0x43</td><td>ローマ字入力OFF, 英大入力。</td></tr>
			<tr><td>0x02</td><td>0x41</td><td>ローマ字入力OFF, 英小入力。</td></tr>
			<tr><td>0x03</td><td>0x3F</td><td>ローマ字入力OFF, かな入力(親指入力)。</td></tr>
			<tr><td>0x04</td><td>0x3D</td><td>ローマ字入力OFF, カナ入力(親指入力)。</td></tr>
			<tr><td>0x05</td><td>0x3B</td><td>ローマ字入力ON, 英大入力。</td></tr>
			<tr><td>0x06</td><td>0x3C</td><td>ローマ字入力ON, 英小入力。</td></tr>
			<tr><td>0x07</td><td>0x58</td><td>ローマ字入力ON, かな入力。</td></tr>
			<tr><td>0x08</td><td>0x64</td><td>ローマ字入力ON, カナ入力。</td></tr>
			<tr><td>0x09</td><td>0x44</td><td>親指シフト動作が無効。フルキー部の拡張キーが固有のコードを返す。<br>キー操作でのモード遷移が無効。</td></tr>
			<tr><td>0x0A</td><td>0x42</td><td>親指シフト動作は有効だが、JIS配列には変換せず、<br>同時打鍵確定マークを付けて送ってくる。<br>それ以外はコマンド0x09と同じ。</td></tr>
		</table>
		<p>LEDが拡張されているキーボードでは、上記モードに合わせてLEDも連動すると思われます。</p>
		<p>やたらめったら入力モードの指定が細かいのは、キーボード操作によるモード遷移を確実に処理できるようにする為です。例えば、ローマ字入力ON・英大入力のときに「カタカナひらがな」を押してかな入力へ遷移させても親指シフト入力はできないようになっています。</p>
		<p>また、後述するように、親指シフト入力中にフルキーの数字や英数記号(,とか)などを入力しようとしたとき、一時的に英字入力へ切り換えたりするようなキーストロークを送ってきますので、モード設定は正確に行っておく必要があります(もちろん、内部モード0x09以降を使ってる場合は別ですが)。</p>
		<p>リセット時には、内部モードは0x01(変換後の値は0x43)になっています。</p>
	</div>
	
	<h3>611ブロック</h3>
	<div class="block">
		<p>続いて、611ブロックのコマンドです。互換ブロックとは別に内部モードを保持しており、こっちにしたがって挙動を変えるものもありますが、個別にON/OFFのコマンドを送って制御するものもあります。</p>
		<p>内部モードが互換ブロックとは違う為、コマンド表の見方も少し変わります。</p>
		<table>
			<tr><th>コマンド</th>	<td>キーボードへ送る上記コマンド列の3バイト目の値。</td></tr>
			<tr><th>モード</th>		<td>当該コマンド実行後、コマンド0x1Cを送ったときに返却される内部モードの値。<br>(値はスキャンコード変換の影響が及ばない範囲である)<br>ハイフンはモード遷移が発生しないことを示す。</td></tr>
			<tr><th>意味</th>		<td>モード遷移が発生するコマンドでは、遷移先モードの説明。<br>遷移が発生しないコマンドでは、コマンドの説明。</td></tr>
		</table>

		<p>コマンド表は以下です。</p>
		<table>
			<tr><th>コマンド</th><th>モード</th><th>意味</th></tr>
			<tr><td>0x11</td><td>--</td><td>フルキー部以外のFMV-KB611で拡張されたキーが、キーコードを出力するようにする。<br>このとき出力されるキーコードは、互換ブロックで親指キー等に固有のコードを<br>出させた場合にも重複しない。</td></tr>
			<tr><td>0x12</td><td>--</td><td>コマンド0x11を無効にする。</td></tr>
			<tr><td>0x13</td><td>0xA1</td><td>互換ブロックの内部モード遷移を、Caps/英字、カタカナひらがな、<br>無変換/変換キーを用いて行うことができる。</td></tr>
			<tr><td>0x14</td><td>0xA2</td><td>互換ブロックの内部モード遷移を、Caps/英字、カタカナひらがなキーのみで<br>行うことができる(無変換/変換キーを押してもモード遷移しなくなる)。</td></tr>
			<tr><td>0x15</td><td>0xA3</td><td>互換ブロックの親指シフト動作を無効にする。<br>互換ブロックの内部モードを0x09に固定する(互換モードのコマンドを送っても変化しなくなる)。</td></tr>
			<tr><td>0x16</td><td>--</td><td>キー操作によって互換ブロックの内部モードが遷移しないようにする。<br>出力されるストロークに変更は無い(かなモードの英数字など)。</td></tr>
			<tr><td>0x17</td><td>--</td><td>コマンド0x16を無効にする。</td></tr>
			<tr><td>0x1C</td><td>--</td><td>611ブロックの内部モード参照コマンド。<br>3バイト目のACKの後に、内部モードの値を返す(1バイト)。</td></tr>
			<tr><td>0x1D</td><td>--</td><td>互換ブロックの内部モード参照コマンド。<br>コマンド0x00と変わらないようである。</td></tr>
			<tr><td>0x1E</td><td>0xA4</td><td>互換ブロックの親指シフト動作を無効にする。<br>が、拡張されたキーのコードが大幅に変更されたものとなる。<br>同時に、フルキー部以外の拡張されたキーもキーコードを出力するようになるが、<br>やはりコードが大幅に変更されたものとなる。</td></tr>
		</table>
		
		<p>尚、リセット時には、各種設定が無効になっており、内部モードは0xA1に設定されています。</p>
		
	</div>
</div>

<h2>拡張されたキーコードの一覧</h2>
<div class="block">
	<p>拡張されているキーのキーコード(106キーボード等と互換のないキーコード)をまとめました。611モードのコマンドのところでも説明した通り、モードの切り換え方に応じて2種類のコードが存在するようですので、それぞれの場合を説明します。</p>
	<p>尚、キーコードは全て16進数表記です。</p>
	
	<h3>コマンド0x09/0x11実行時(又は互換ブロック使用時)に出力されるコード</h3>
	<div class="block">
		<p>まず、コマンド0x09(又は0x0A)と0x11を送ったときのキーコードをまとめたものです。</p>
		<table border="1">
			<tr><th RowSpan="2" Align="Center">キー名称</th><th ColSpan="2" Align="Center">スキャンコード1</th>
			<th ColSpan="2" Align="Center">スキャンコード2</th><th ColSpan="2" Align="Center">スキャンコード3</th></tr>
			<tr><th>MAKE</th><th>BREAK</th><th>MAKE</th><th>BREAK</th><th>MAKE</th><th>BREAK</th></tr>
			<tr><td>取消</td>				<td>64</td><td>E4</td><td>08</td><td>F0 08</td><td>28</td><td>F0 28</td></tr>
			<tr><td>実行</td>				<td>5D</td><td>DD</td><td>2F</td><td>F0 2F</td><td>18</td><td>F0 18</td></tr>
			<tr><td>親指左</td>			<td>65</td><td>E5</td><td>10</td><td>F0 10</td><td>30</td><td>F0 30</td></tr>
			<tr><td>親指右</td>			<td>66</td><td>E6</td><td>18</td><td>F0 18</td><td>38</td><td>F0 38</td></tr>
			<tr><td>同時打鍵(親指左)</td>	<td>67</td><td>E7</td><td>20</td><td>F0 20</td><td>40</td><td>F0 40</td></tr>
			<tr><td>同時打鍵(親指右)</td>	<td>68</td><td>E8</td><td>28</td><td>F0 28</td><td>48</td><td>F0 48</td></tr>
			<tr><td>英字</td>				<td>63</td><td>E3</td><td>5E</td><td>F0 5E</td><td>20</td><td>F0 20</td></tr>
			<tr><td>罫線通過(PF13)</td>	<td>56</td><td>D6</td><td>61</td><td>F0 61</td><td>13</td><td>F0 13</td></tr>
			<tr><td>かな縮小(PF14)</td>	<td>76</td><td>F6</td><td>5F</td><td>F0 5F</td><td>06</td><td>F0 06</td></tr>
			<tr><td>文字拡縮(PF15)</td>	<td>6D</td><td>ED</td><td>50</td><td>F0 50</td><td>0B</td><td>F0 0B</td></tr>
			<tr><td>図形表示(PF16)</td>	<td>6F</td><td>EF</td><td>6F</td><td>F0 6F</td><td>0A</td><td>F0 0A</td></tr>
			<tr><td>枠空け(PF17)</td>		<td>6C</td><td>EC</td><td>48</td><td>F0 48</td><td>09</td><td>F0 09</td></tr>
			<tr><td>線画(PF18)</td>		<td>72</td><td>F2</td><td>39</td><td>F0 39</td><td>04</td><td>F0 04</td></tr>
			<tr><td>グラフ作成(PF19)</td>	<td>74</td><td>F4</td><td>53</td><td>F0 53</td><td>03</td><td>F0 03</td></tr>
			<tr><td>イメージ(PF20)</td>	<td>75</td><td>F5</td><td>5C</td><td>F0 5C</td><td>01</td><td>F0 01</td></tr>
		</table>
		<div class="memo">
			<div class="memo_blk1">注</div>
			<div class="memo_blk2"><p>表中の「同時打鍵」は、互換ブロック内部モード0x0A時に当該親指キーとの同時打鍵を検出したときに通知されるコードです。文字キーコードをメイクとブレイクで挟んで通知されます。具体的な取り扱い方法については後述します。</p></div>
		</div>
	</div>

	<h3>コマンド0x1E実行時に出力されるコード</h3>
	<div class="block">
		<p>次に、コマンド0x1Eを送ったときのキーコードをまとめたものです。</p>
		<table border="1">
			<tr><th RowSpan="2" Align="Center">キー名称</th><th ColSpan="2" Align="Center">スキャンコード1</th>
			<th ColSpan="2" Align="Center">スキャンコード2</th><th ColSpan="2" Align="Center">スキャンコード3</th></tr>
			<tr><th>MAKE</th><th>BREAK</th><th>MAKE</th><th>BREAK</th><th>MAKE</th><th>BREAK</th></tr>
			<tr><td>取消</td>				<td>E0 01</td><td>E0 81</td><td>E0 76</td><td>E0 F0 76</td><td>08</td><td>F0 08</td></tr>
			<tr><td>実行</td>				<td>E0 6B</td><td>E0 EB</td><td>E0 40</td><td>E0 F0 40</td><td>5F</td><td>F0 5F</td></tr>
			<tr><td>親指左</td>			<td>E0 7B</td><td>E0 FB</td><td>E0 67</td><td>E0 F0 67</td><td>85</td><td>F0 85</td></tr>
			<tr><td>親指右</td>			<td>E0 79</td><td>E0 F9</td><td>E0 64</td><td>E0 F0 64</td><td>86</td><td>F0 86</td></tr>
			<tr><td>同時打鍵(親指左)</td>	<td RowSpan="2" ColSpan="6" Align="Center">互換ブロック内部モード0x0Aが使えないので<br>値が存在しない</td></tr>
			<tr><td>同時打鍵(親指右)</td>	</tr>
			<tr><td>英字</td>				<td>E0 3A</td><td>E0 BA</td><td>E0 58</td><td>E0 F0 58</td><td>14</td><td>F0 14</td></tr>
			<tr><td>罫線通過(PF13)</td>	<td>5B</td><td>DB</td><td>1F</td><td>F0 1F</td><td>08</td><td>F0 08</td></tr>
			<tr><td>かな縮小(PF14)</td>	<td>5C</td><td>DC</td><td>27</td><td>F0 27</td><td>10</td><td>F0 10</td></tr>
			<tr><td>文字拡縮(PF15)</td>	<td>5D</td><td>DD</td><td>2F</td><td>F0 2F</td><td>18</td><td>F0 18</td></tr>
			<tr><td>図形表示(PF16)</td>	<td>63</td><td>E3</td><td>5E</td><td>F0 5E</td><td>20</td><td>F0 20</td></tr>
			<tr><td>枠空け(PF17)</td>		<td>64</td><td>E4</td><td>08</td><td>F0 08</td><td>28</td><td>F0 28</td></tr>
			<tr><td>線画(PF18)</td>		<td>65</td><td>F5</td><td>10</td><td>F0 10</td><td>30</td><td>F0 30</td></tr>
			<tr><td>グラフ作成(PF19)</td>	<td>66</td><td>F6</td><td>18</td><td>F0 18</td><td>38</td><td>F0 38</td></tr>
			<tr><td>イメージ(PF20)</td>	<td>67</td><td>F7</td><td>20</td><td>F0 20</td><td>40</td><td>F0 40</td></tr>
		</table>
		<div class="memo">
			<div class="memo_blk1">注</div>
			<div class="memo_blk2"><p>コマンド0x1E時のコード表のうち、「取消」は「Esc」の、「親指左」は「無変換」の、「親指右」は「変換」の、「英字」は「CapsLock」の拡張フラグ付コードになります。「実行」も拡張フラグ付ですが、当該コードは一般的なキーボードには存在しません。拡張フラグが使えないスキャンコード3では、これらのキーの区別ができませんので注意してください。</p></div>
		</div>
		
		<p>なお、うちの機械では、マザーボード上でのスキャンコード2->1変換が有効な場合も、これらの表の通り正しく変換されました。この変換テーブル自体はキー毎に定義されている訳ではなく、バス上を流れるバイトパターン全て(256通り)に対して定義されているようですので、問題は無さそうです。実際、富士通のドライバやサニコンのドライバも、スキャンコード変換を有効にした状態で使っているようですので…(当該ドライバを使ってシステムを立ち上げたあと、切替器で別の計算機に切り換えて、キーコードを吐かせたところ、スキャンコード2になってました)。</p>
	</div>
</div>

<h2>親指シフトの実現方法</h2>
<div class="block">
	<p>ここから、具体的に親指シフト入力を実現する為の方法などを説明します。ここまでの説明を踏まえると、このキーボードを使えば以下の3つの手段で対応できそうです。</p>
	<ul class="list">
		<li>キーボード側にはキースイッチのメイク/ブレイクのみ送らせ、同時打鍵の判定からかなの出力まで全てソフト側で処理する</li>
		<li>キーボード側では同時打鍵の判定のみ行わせ、NICOLA配列への変換はソフト側で行う</li>
		<li>キーボードでJISかな操作に変換して出力させる</li>
	</ul>
	
	<p>もし親指シフトエミュレータが既にあるような環境であれば、実のところ一番上がもっとも簡単な対応です。また、「親指シフトの実装は無いが、キーボードのモディファイヤ定義(文字のシフトパターン)を増やすことはできる」環境であれば2番目がおすすめです。何度も説明していますように、3番目は「ドライバが作れない環境で使うための最後の手段」と考えた方が賢明です。</p>

	<p>それでは、これより各手段について具体的に説明します。</p>

	<h3>キーボード側にはキースイッチのメイク/ブレイクのみ送らせる</h3>
	<div class="block">
		<p>この場合は、キーボードの制御は一番簡単です。システムの起動時に、一度だけコマンド0x09を送るだけです。これで、フルキー部の全キーを把握できます。</p>
		<p>コマンド0x09の代わりに、コマンド0x15を送ることでも実現できます。コマンド0x09だとKB211と互換がとれますが、KB211ではこのモードにおいても「親指右+後退/取消」の処理の為、親指右の単独打鍵確定に時間が掛かってしまうので、自前親指処理が困難です。なので、この場合はKB211との互換を捨てても問題は無いように思います。</p>

		<p>あとは、送られてくるキーコードのタイミングに合わせて、同時打鍵判定などを行うだけです。結局やることはエミュレータを実装するのと全く同じです。このあたりの実装については、親指シフトエミュレータ「親指ひゅんQ」に付属する「親指ひゅんQの同時打鍵ステートマシン」解説文書、日本語入力コンソーシアムの「NICOLA配列規格書」内にある実装例、JIS規格案などが参考になります。また、手前味噌ですが、「<a href="./exe_w.htm">親指の友 Mk-2ドライバ</a>」にはソースコードも同封していますので、参考になるかもしれません。</p>

		<p>他にも、対象となるプラットフォームに親指エミュレータが存在するのであれば、そちらで都合が良いようにキーコードを置き換えて出力する、という処理でも良いかもしれません。この場合、出力されるコードが106キーボードとなじみ易い、コマンド0x1Eを使うのも良いでしょう。</p>
	</div>

	<h3>キーボード側で同時打鍵の判定のみ行わせる</h3>
	<div class="block">
		<p>こちらの場合は少々コマンドのやりとりが増えます。システムの入力モード変化に合わせて、モード遷移コマンド(0x0A/0x09)を送る必要があります。ただし、先の表の全パターンを送る必要はなく、ざっくりと、かな・カナ入力時にコマンド0x0A、それ以外の場合はコマンド0x09を送信します。</p>
		<p>モード0x09のとき、フルキー部分のキーは全て固有のキーコードを返すようになります。このときのコードは先の表に示した通りです。親指キーも固有のキーコードを出力するようになりますので、英数入力モードではスペース文字の入力に割り当てると良いと思います。</p>

		<p>モード0x0Aのときは、モード0x09の動作に加えて、親指シフトの同時打鍵監視・通知動作が追加されます。このモードで同時打鍵の操作を行った場合、以下のような順番でキーコードが通知されます。</p>
		  
		<div class="memo">
			<div class="memo_blk2">
				<ol class="list">
					<li>親指キー メイク</li>
					<li>同時打鍵マーク メイク</li>
					<li>文字キー メイク</li>
					<li>同時打鍵マーク ブレイク</li>
					<li>文字キー ブレイク</li>
					<li>親指キー ブレイク</li>
				</ol>
			</div>
		</div>

		<p>これを見ると、「同時打鍵マーク」が、あたかもモディファイヤ(ShiftやCtrlなど)のように文字キーを挟む形で出力されることがわかります。つまり、このコードを「仮想の」モディファイヤキーとして使い、「同時打鍵マーク+文字キー」に対応する文字を割り当てれば、親指シフト入力を簡単に実装できます。あとは必要に応じて、計算機側で濁音や半濁音を追加出力すればOKです。</p>

		<p>尚、同時打鍵マークは同時打鍵した親指キーによってコードが変わります(先のコード表を参照)ので注意が必要です。つまり、ストレートシフト(同じ側の手との同時打鍵)なのかクロスシフト(反対側の手との同時打鍵)なのかは、計算機側で判別してやる必要があります。また、親指キーのコード自体も一緒に通知されるので、同時打鍵時はこれを無視する必要があります。こちらは、親指シフト入力時の親指キー単独打鍵を無視するように実装することが多いので、それに倣えば特に問題ないと思われます。</p>

		<p>ちなみにモード0x0Aの状態では、親指キーとの同時打鍵監視の為、フルキー部の文字キー単独打鍵通知がもたつくようになります(JIS配列変換を有効にした状態で親指入力しているときと同じ位)。なので、親指シフト入力をしない入力モードのときは、モード0x09に切り換えておかないと使い勝手が悪くなってしまいます。</p>
	</div>

	<h3>キーボードでJISかな操作に変換して出力させる</h3>
	<div class="block">
		<p>基本的な制御のスタイルとしては、システム側の入力モードに連動してコマンド0x01～0x08をキーボードへ送ればOKです。</p>

		<p>これだけ書くととても簡単なように思えますが、そうはいかないのが面倒くさいところです。まず問題になるのが「あるキー操作を行うと勝手に内部モードが変わってしまいまう」ことです。具体的には以下の操作を行うと、内部モードが勝手に遷移してしまいます。</p>
		
		<ul class="list">
			<li>CapsLock、カタカナひらがなの単独打鍵</li>
			<li>英字の単独打鍵(CaosLockの打鍵として通知される)</li>
			<li>無変換、変換の単独打鍵(直前にカタカナひらがなの打鍵が通知される)</li>
			<li>他(ローマ字入力を切り換える操作)</li>
		</ul>

		<p>Windows上では、これらのキー操作は(意図する動作かは別として)何かしら入力モードの遷移と絡むように働いていますので、先程のスタイル通りに対処すれば何事もなく対策できます。しかし、例えば「CapsLockとCtrlの入れ換え(システム側でのコードの読み替え)をしている」とか、これらのキーを操作してもシステム側で入力モードの変更が発生しない状態にされている場合、このままでは確実にモードずれを起こしてしまいます。</p>

		<p>KB211との互換性を捨てても良いのであれば、コマンド0x16を送ってモード遷移が発生しないようにしてしまうのが、一番手っとり早い解決方法です。しかし、KB211と処理を共通化するのであれば、この方法は使えません。ここで上記の操作を見ると、いずれも必ずCpasLockかカタカナひらがなを含む操作なので、キーボード割り込みのハンドラ等で、これらのキーコードを発見し次第、現在の入力モードをキーボードへ通知するのが無難な対策でしょう(但し、後述の問題に引っかかる)。</p>

		<p>次に直面するのが、かな入力中に「JIS配列の英字側にしか存在しない文字」を入力したときの動作です。例えば、かな入力時に「フルキーの1」を入力すると、以下のような操作が通知されます。</p>
		<div class="memo">
			<div class="memo_blk2">
				<div class="list">(キーメイク)</div>
				<ol class="list">
					<li>「CapsLock」のメイクとブレイク</li>
					<li>「1」のメイク</li>
				</ol>
				<div class="list">(キーブレイク)</div>
				<ol class="list">
					<li>「1」のブレイク</li>
					<li>「カタカナひらがな」のメイクとブレイク</li>
				</ol>
			</div>
		</div>
		
		<p>つまり、「一瞬だけ英字入力モードへ切り換えて、キーを離したら元のかなモードへ戻る」ようなキー操作を、勝手に送ってきます。しかもこの処理は、JISかな配列に無い英数字・記号を入力する必須の処理である為、コマンド0x16を送っても無効になりません。</p>

		<p>一見すると、元に戻るコードまで送ってきているので特に問題無いように見えます。しかし、これまでに実装しているような対策をとっていると問題があります。例えばこんな感じです。
		<div class="memo">
			<div class="memo_blk2">
				<div class="list">(キーメイク)</div>
				<ol class="list">
					<li>「CapsLock」のメイクとブレイク<br>→モード遷移する操作なので、正しいモードをキーボードに再送信</li>
					<li>「1」のメイク</li>
				</ol>
				<div class="list">ここでバスが空くので、実際に「英字入力モード(0x02か0x01)」の設定コマンドを発行</div>
				<div class="list">(キーブレイク)</div>
				<ol class="list">
					<li>「1」のブレイク</li>
					<li><b>「カタカナひらがな」のメイクとブレイクが来ない!</b></li>
				</ol>
			</div>
		</div>
		
		<p>このように、途中で英字入力に切り換えてしまうと、後半の「カタカナひらがな」に関する操作が送られずに処理が終わってしまいます。しかも、以降の内部モード遷移が若干挙動不審になるようです(かな入力に遷移させても、カナ入力時の操作が出力される、等)。これがまさしく、Windows NT系標準のKB211用ドライバで「フルキー部の数字を入力すると英字入力になる」問題の原因であります。</p>

		<p>さらに、上記のストロークでは、「CapsLock」が「英字入力への遷移」、「カタカナひらがな」が「かな入力への遷移」と決めうちして使用されています。つまり、これらのキーが上記以外の目的で使われている場合もうまくいきません。</p>
		<p>これらの問題を解決するためには、機械的に出力されたコードとユーザの手操作を判別して、それぞれ別系統で処理することが必要不可欠です。しかし、上記ストローク中のCapsLock/カタカナひらがなを、ユーザが本当にキーを押して出力されたコードと区別する方法は、少なくともキーコードを見ただけでは分かりません。</p>

		<p>そこで、キーコードが送られてくる時間を見て分別する方法を検討してみます。上記ストローク中の、CapsLockメイク～「1」メイクまでは一気に送られてきます。	かなり遅く見積もっても(データが化けて再送要求が頻発したときなどでも)、数十ms以内には全て受信できるはずです。一方で、ユーザが手でこのストロークを入力したとしても、通常ここまでの速さで入力することは無いと思われます(CapsLockの単独打鍵だけならあり得ると思いますが…)。</p>

		<p>これを踏まえると、「CapsLockのメイク、ブレイク、任意のキーのメイク(フルキー部の文字キー以外にも、左Shiftが出現する場合あり)が、この順かつ連続に、一定期間内に通知されたとき」に、これを機械的な出力であると見なし、それ以外の場合はユーザ操作の入力とみなせば、おおむね上手く行くと考えられます。	「親指の友」ドライバでも、V1.0L20よりこのロジックで対策するようにしています。同じような方法かはわかりませんが、サニコンのドライバでも何かしらの対策を取っているようです。</p>

		<p>このように、ちゃんとやろうとすると非常に面倒な実装が必要になってしまいます。</p>
	</div>
</div>

<h2>最後に</h2>
<div class="block">
	<p>こういう、キーボードみたいな仕事道具は「手に馴染んでナンボ」のものだと思います。そいつが「特殊な制御を必要とするから」といった理由で使える場面が制限されてしまうのは勿体ないと思います。とりあえず、このページでは制御に必要な情報を一通りのせておきました。また、これを使って<a href="./dev_hw.htm">USBへの変換</a>や<a href="./exe_w.htm">Windows 8以降でも使えるドライバ</a>も作っておきました。他の環境への対応は誰か頑張ってください(ぇ)。FMV-KB611自体は、親指シフト環境を簡単に実現できる優秀かつ弄り甲斐のあるキーボードだと思いますので、よりいっそう普及してくれればと思います。</p>
	<p>記載内容に対するご意見等ありましたら、<a href="http://development-room.bbs.fc2.com/">ゲストブック</a>か<a href="index.html#footer">メール</a>にてお願いします(アドレス等は帰還先のメインページに記載)。</p>
	
	<div class="memo">
		<div class="memo_blk1">ノートマシンのキーボード</div>
		<div class="memo_blk2">
			<p>ノートマシンに搭載されている親指シフトキーボードって、親指キーと変換/無変換が
統合されたりしてしまってますが、全く同じ方法で制御できるんでしょうかね?</p>
			<p>2006/10/08追記: 泊何水さんの情報によると、親指ノートのキーボードは内部的に通常のJISキーボードのようです。うーん残念…。</p>
		</div>
	</div>
	
	<div class="memo">
		<div class="memo_blk1">KB211に関するメモ</div>
		<div class="memo_blk2">
			<p>何度かさらりと触れていますが、上記互換ブロックの動作は、FMV-KB211とほぼ同じ実装になっています。即ち、<B>KB211でも、JISかな配列の出力を止めたり、親指キーに固有のコードを吐かせたり、同時打鍵の監視だけさせるモードにしたりできるということです。</B>このとき、親指キー等で出力されるコードは、KB611のコード(コマンド0x09時)と全く同じになります。また、Tabキーのコードも英字キーのコードに変わります(つまりTabキーが消滅する)。</p>
			<p>但し、親指右と後退/取消を同時打鍵することで、BackSpaceやEscのコードを通知する機能を無効にすることが出来ない為、親指右のコードが出力されるまでにもたつきが生じます。結果として、KB611のように自前で同時打鍵の判定を行うと使い勝手が非常に悪くなります。また、「後退」/「取消」は基本的に「* :」/「} ]」キーであり、モード0x09/0x0A時には必ずこれらのキーに相当するコードが出力されます。後退や取消として使いたい場合は、システム側でコードを読み替える必要があります。</p>
			<p>これ以外の動作に関してはほとんど同じなので、例えば同時打鍵判定をキーボードにやらせて、JISかな変換の弊害から解放させる、ということも可能です。こちらの制御の場合ですと、今までの場合だとほとんど不可能に近かった、CapsLockとCtrlの入れ換え等も問題なく行えるはずです。この方法で実装するドライバが現れれば、KB211の株も少しは上がるのでは無いのでしょうか。</p>
		</div>
	</div>
	
</div>
</div>

<div class="footer">
	<div style="text-align:center"><a href="index.html">トップページ</a></div>
	<div style="font-size:12px; text-align:right">Copyright(c) 2006 聖人(Kiyoto).</div>
</div>

<!-- [FC2 Analyzer] //analyzer.fc2.com/  -->
<script language="javascript" src="//analyzer51.fc2.com/ana/processor.php?uid=2455023" type="text/javascript"></script>
<noscript><div align="right"><img src="//analyzer51.fc2.com/ana/icon.php?uid=2455023&ref=&href=&wid=0&hei=0&col=0" /></div></noscript>
<!-- [FC2 Analyzer]  -->

</body>
</html>
